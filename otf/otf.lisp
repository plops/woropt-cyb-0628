(in-package :otf)
 
(declaim (optimize (debug 2) (safety 2) (speed 3)))
 
(defun i0 (k vartheta &key (alpha .9s0) (epsabs .01) (epsrel .0001))
  (declare (single-float k)
	   ((single-float -6s0 6s0) vartheta alpha)
	   (values single-float &optional))
  (let ((pi-s #.(coerce pi 'single-float)))
    (unless (<= 0 vartheta pi-s)
     (return-from i0 0s0))
    (let* ((cv (cos vartheta))
	   (sv (sin vartheta))
	   (ca (cos alpha))
	   (sqca (sqrt ca))
	   (ca^3/2 (* ca sqca))
	   (ca^5/2 (* ca^3/2 ca))
	   (aa (/ (- (/ 16s0 15s0) ;; aplanatic scaling factor
		     (* 2/3 ca^3/2)
		     (* 2/5 ca^5/2))))
	   (cc-fac (if (= k 0s0)
		       (return-from i0 0s0) ;; FIXME figure out central
		       (/ (* 16s0 pi-s (* aa aa)) k)))
	   (k2/4 (/ (* k k) 4s0))
	   (r0 (if (<= k2/4 1s0)
		   (let ()
		     (declare ((single-float 0s0 1s0) k2/4))
		     (sqrt (- 1s0 k2/4)))
		   (return-from i0 0s0) #+nil (error "outside of support")))
	   (beta1-arg (if (= 0s0 (* r0 sv))
		       1s0 #+nil (error "either k or theta is 0 will divide by zero")
		       (/ (+ (* 2s0 (cos alpha))
			     (* k (abs cv)))
			  (* 2s0 r0 sv))))
	   (beta1 (if (< -1s0 beta1-arg 1s0)
		   (let () 
		     (declare ((single-float -1s0 1s0) beta1-arg)) 
		     (acos beta1-arg))
		   0s0))
	   (sum (qng:qng 
		 #'(lambda (phi) 
		     (declare ((single-float 0s0 #.(coerce (/ pi 2)
							   'single-float)) phi)
			      (values single-float &optional))
		     (let* ((cp2 (cos phi))
			    (sp2 (sin phi))
			    (a (* r0 cv cp2))
			    (b (* (/ k 2s0) sv))
			    (d (* r0 sp2))
			    (s1 (- (- (* r0 sv cp2))
				   (* (/ k 2s0) cv)))
			    (s2 (+ (- (* r0 sv cp2))
				   (* (/ k 2s0) cv)))
			    (j4 (/ (+ (- (* a a) (* b b))
				      (* d d))
				   2s0))
			    (a2 (* a a))
			    (b2 (* b b))
			    (d2 (* d d))
			    (j5 (/ (- a2 b2 d2) 2s0))
			    (ss1 (/ s2 (- 1s0 s1)))
			    (ss2 (/ s1 (- 1s0 s2)))
			    (ss3 (/ 1s0 (* (- 1s0 s1) (- 1s0 s2))))
			    (a-b (- a b))
			    (a+b (+ a b))
			    (ll (+ (* (/ ss1 2s0) (+ (* a-b a-b) d2))
				   (* (/ ss2 2s0) (+ (* a+b a+b) d2))))
			    (j0 (+ (* (/ ss3 2s0) (+ (* 3s0 (* j4 j4))
						     (* b2 d2))
				      (- ll) (+ s1 s2))))
			    (a2-b2 (- a2 b2))
			    (j1 (+ (* (/ ss3 2) (- (* d2 d2) (* a2-b2 a2-b2)))
				   (- ll (* (+ ss1 ss2) d2))))
			    (j2 (* (/ ss3 2) (- (* j5 j5) (* a2 d2))))
			    (j3 (* (/ ss3 2) (- (* j4 j4) (* b2 d2))))
			    (ccint (+ j0 j3 j4)))
		       (let ((s1s2 (* s1 s2)))
			 (when (< s1s2 0s0)
			   (return-from i0 0s0)
			   #+nil (error "s1*s2 should be positive but isn't"))
			 (let ()
			   (declare ((single-float 0s0) s1s2))
			   (* (sqrt s1s2) ccint)))))
		 0s0 beta1 :epsabs epsabs :epsrel epsrel)))
      (* cc-fac sum))))

#+nil
(let ((k .2s0)
      (theta .3s0))
 (- 
  (i0 k theta)
  (i0 k theta)))
 
#+nil
(progn
  (dotimes (i 20)
    (terpri))
 (let ((nalpha 38))
   (dotimes (alpi nalpha)
     (let* ((alpha (* alpi (/ (coerce (/ pi 2) 'single-float) (- nalpha 0))))
	    (w 42)
	    (h 25)
	    (a (make-array (list h w) :element-type 'single-float)))
       (format t "alpha=~3,1f degree~%" (* alpha (/ 180s0 pi)))
       (dotimes (j h)
	 (dotimes (i w)
	   (let*((x (* (- i (floor w 2)) (/ 3s0 w)))
		 (z (* j (/ 2.1s0 h)))
		 (theta (atan z x))
		 (k (sqrt (+ (* x x) (* z z)))))
	     (setf (aref a j i) (i0 k theta :alpha alpha :n 100)))))
       (let* ((ab (sb-ext:array-storage-vector a))
	      (ma (reduce #'max ab))
	      (mi (reduce #'min ab)))
	 (dotimes (j h)
	   (dotimes (i w)
	     (let ((v (aref a j i)))
	       (if (= v 0.0)
		   (format t "  ")
		   (format t "~2,'0d" (floor (* .04  (abs v)))))))
	   (terpri))
	 (terpri))))))
